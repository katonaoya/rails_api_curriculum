## APIとは
APIとはソフトウェアやアプリケーションなどの一部を外部に向けて公開することにより、第三者が開発したソフトウェアと機能を共有できるようにしてくれるものです。USBは外部デバイスとパソコンを繋ぐインターフェースですが、APIはソフトウェア同士を繋げます。つまり、異なるソフトウェアやサービス間で認証機能を共有したり、チャット機能を共有したり、片方から数値データを取り込み、別のプログラムでそのデータを解析したりできるようになります。
APIを公開する、とはわかりやすく言うと、ソフトウェアにAPIという外部とやりとりする窓口を作り、外部アプリとコミュニケーションや連携ができる状態にする、ということです。鎖国時代の日本と諸外国は連携することが困難でしたが、諸外国との貿易を許されていた唯一の場所である長崎の出島をうまく活用することで、日本との貿易や文化交流、情報交換が行えるようになった、という歴史の話がありますが、日本を一つのソフトウェア、諸外国をまた別のソフトウェアと考えると、出島が司っていたのが言ってみればその二つを繋げるAPI機能です。

## JWTとは
JSON Web Token（JWT）は、JSONオブジェクトによるメンバー間の安全な通信方式を定義するオープンスタンダード（RFC 7519）です。「署名」のおかげでこの情報を認証し、信頼できるブックマークすることができます。JWTの署名はHMACまたはRSAで暗号化されます。

## JSONとは
JSONとは「JavaScript Object Notation」の略で、「JavaScriptのオブジェクトの書き方を元にしたデータ定義方法」のことです。
JavaScriptでオブジェクトを作成する際は {} や [] などの括弧を使って記述しますが、JSONはその記法を元にしています。元々はJavaScriptで使われる想定で作成されたデータ構造なので、JavaScriptと非常に相性が良いです。現在はJavaScript以外にもPythonやJava、PHPなどの幅広い言語で使われていて、JavaScriptなどのクライアント言語とPythonなどのサーバサイド言語間のデータのやり取りで使われることが多いです。

## トークン
認証のための鍵を格納するものや、ワンタイムパスワードを生成して表示するもの。認証のための印。

## config.generators
rails gしたときの生成されるファイルの設定ができる。
g.assets false          ## CSS, JavaScriptファイル生成せず
g.skip_routes false     ## trueならroutes.rb変更せず、falseなら通常通り変更
g.helper false          ## helper関連のファイルを作成しない。

## モジュール
モジュールはクラスメソッドの親の存在。モデルやコントローラなどで共通で利用できるメソッドを定義することができる。
モジュールが複数になり、複雑になるようであれば、appディレクトリにservicesディレクトリを作成し、その中にモジュールを格納していくことで、モジュールの管理がしやすくなる。
extend selfと記載することで、自身の持つメソッド全てを自身のクラスメソッドとして定義する。

## serializer
データの入出力を扱い、モデルへの橋渡しをするクラス。

## active_model_serializer
最近ではRailsをAPIモードで開発する機会も多い。 ActiveModelSerializers: JSONオブジェクトを作成するオブジェクトの作成を支援するライブラリです。
```
bundle exec rails g serializer モデル名
```
でserializersディレクトリとモデルファイルが作成される。

## app/serializers/user_serializer.rb
attributesメソッドにシンボルを渡すと、render jsonなどでJSONオブジェクトを表示させた際にレスポンスされるkeyとvalueを絞り込むことができます。
```
class UserSerializer < ActiveModel::Serializer
  attributes :id, :name, :email
end
```

## config/initializers/active_model_serializer.rb
データの表示形式のデフォルトを設定することができる。
```
ActiveModelSerializers.config.adapter = :json 
```
この場合だとJSON表示形式で、レスポンスが返ってくる。

## app/services/jwt/user_authenticator.rb
userの認証に関するモジュールを作成する。
```ruby
module Jwt::UserAuthenticator
  extend self

  def call(request_headers)
    @request_headers = request_headers
  # beginは通常の処理を書いて、rescueにエラー発生時の処理を書く。
    begin
    # tokenを複合したものをpayloadに入れる。
      payload, = Jwt::TokenDecryptor.call(token)
    # payloadのuser_idとUserクラスのインスタンスのidが合致したものを探してくる。
      User.find(payload['user_id'])
    # StandardErrorが起こった時には
    rescue StandardError
    # nilを返す。
      nil
    end
  end

  private

  def token
  # リクエストヘッダの中に含まれている認証のデータの半角スペースを区切り文字とし、配列にするしたものの最後をトークンメソッドとする。
    @request_headers['Authorization'].split(' ').last
  end
end
```
リクエストヘッダの中に含まれている認証のデータの半角スペースを区切り文字とした配列の最後（パケット通信においてパケットに含まれるヘッダやトレーラなどの付加的情報を除いた、データ本体）の中のuser_idのUserを探しだす。

## 鍵について
https://hirocorpblog.com/rails-credentials-master/
configの中に鍵が入っている。
#### credentials.yml.enc => 公開鍵
#### master.key => 秘密鍵

## app/services/jwt/token_decryptor.rb
tokenを複合化するモジュールを作成する。
https://techtechmedia.com/environment-variable-aws/
```ruby
module Jwt::TokenDecryptor
  extend self

  def call(token)
  # 引数で渡された暗号を複合化する。
    decrypt(token)
  end

  private

  def decrypt(token)
  # JWTのtokenと公開鍵の中のCookieの暗号化に用いられる文字列を元に戻すメソッド。
    JWT.decode(token, Rails.application.credentials.secret_key_base)
  # StandardErrorが起こるという例外が起こった時には
  rescue StandardError
  # 強制的にInvalidTokenErrorをを発生させてプログラムを強制的に終了することができる。
    raise InvalidTokenError
  end
end
class InvalidTokenError < StandardError; end
```

## token_provider.rb
provider…トークンの供給者
payload…IT用語としては、パケット通信においてパケットに含まれるヘッダやトレーラなどの付加的情報を除いた、データ本体のことである。
```ruby
module Jwt::TokenProvider
  extend self

  def call(payload)
    issue_token(payload)
  end

  private

  # トークンを発行する。
  def issue_token(payload)
  # JWTのpayloadと公開鍵の中のCookieの暗号化に用いられる文字列を元に戻すメソッド。
    JWT.encode(payload, Rails.application.credentials.secret_key_base)
  end
end
```

## app/controllers/application_controller.rb
CSRF… Web アプリケーションのユーザー（利用者）に意図しない通信リクエストを送信させ、利用者の意図しない処理をサービスに実行させることが可能となる脆弱性、またはその脆弱性を利用した攻撃手法を指します。
```ruby
# CSRF(クロスサイトリクエストフォージェリ)対策のコード。
  protect_from_forgery with: :null_session
  class AuthenticationError < StandardError; end

# rescue_from エラー名, with: :メソッド名
# エラー名が起こった時、メソッド名を実行させる。
  rescue_from ActiveRecord::RecordInvalid, with: :render_422
  rescue_from AuthenticationError, with: :not_authenticated

# ログインユーザーでなければAuthenticationErrorを発生させてプログラムを強制的に終了させる。
  def authenticate
    raise AuthenticationError unless current_user
  end

# @current_userがnilだったら、リクエストヘッダの中に含まれている認証のデータの半角スペースを区切り文字とした配列の最後（パケット通信においてパケットに含まれるヘッダやトレーラなどの付加的情報を除いた、データ本体）の中のuser_idのUserを探しだす。
  def current_user
    @current_user ||= Jwt::UserAuthenticator.call(request.headers)
  end

  private

  def render_422(exception)
  # unprocessable_entity => 処理できないエンティティ（存在）
  # unprocessable_entity状態で例外エラーのエラーメッセージをJSON形式で呼び出す。
    render json: { error: { messages: exception.record.errors.full_messages } }, status: :unprocessable_entity
  end

  # unauthorized状態でログインしてくださいというメッセージをJSON形式で表示する。
  def not_authenticated
    render json: { error: { messages: ['ログインしてください'] } }, status: :unauthorized
  end
```

## app/controller/api/sessions_controller.rb
```ruby
def create
  user = User.find_by(email: session_params[:email])
# &.はぼっち演算といい、&の前のオブジェクトがnilだった場合、デフォルトではエラーを返すようになっているが、ぼっち演算を使うことによって、nilを返すようになる。
  if user&.authenticate(session_params[:password])
  # userのidのトークンを発行する。
    token = Jwt::TokenProvider.call(user_id: user.id)
  # serializer: UserSerializerでUserSerializerを経由してデータを取得することができる。
  # as_jsonでモデルをハッシュ形式のJSONに変換。
  # mergeはハッシュが何層にもなっている場合（ハッシュの中にハッシュがある）と一番表面のハッシュのみ結合するが、deep-mergeをすると全ての階層をmergeしてくれるようになる。
  # UserSerializerを通して、userを引数に渡したオブジェクトを作成し、発行したトークン情報を持つuserをオブジェクトに統合したものをJSON形式の情報で返す。
    render json: ActiveModelSerializers::SerializableResource.new(user, serializer: UserSerializer).as_json.deep_merge(user: { token: token })
  else
  # JSON形式でエラーメッセージを出す。
    render json: { error: { messages: ['メールアドレスまたはパスワードに誤りがあります。'] } }, status: :unauthorized
  end
end
```

# RSpecについて
## factories
テストをする時専用のデータセットを設定する。factoryはspecフォルダに格納されている。

## spec/reauests/api/sessions_request_spec.rb
Ruby on Rails 5 速習実践ガイドを参考
```ruby
# Api::Sessionsを対象にrequest_typeのテストを行う。
RSpec.describe "Api::Sessions", type: :request do
# /sessionにPOSTリクエストを送るという動作を対象にする。
  describe 'POST /session' do
  #let(定義名) { 定義の内容 }
    let!(:user) { create(:user) }
    context '認証情報が正しい場合' do

      let(:session_params) { { session: { email: user.email, password: '12345678' } } }
      it 'ログインに成功すること' do
        post api_session_path, params: session_params
      # httpが200という値を持っているというレスポンスをすることを期待する。
        expect(response).to have_http_status(200)
      # response.bodyをJSON形式からruby形式に変換してjson変数に入れる。
        json = JSON.parse(response.body)
      # jsonのuserにincludi以下の値が入っていることを期待する。
        expect(json['user']).to include({
                                       'id' => user.id,
                                       'name' => user.name,
                                       'email' => user.email,
                                       'token' => be_present
                                   })
      end
    end

    context '認証情報に誤りがある場合' do
      let(:invalid_session_params) { { session: { email: user.email, password: '1234' } } }
      it 'ログインに成功すること' do
        post api_session_path, params: invalid_session_params
        expect(response).to have_http_status(401)
        json = JSON.parse(response.body)
        expect(json['error']).to be_present
      end
    end
  end
end
```